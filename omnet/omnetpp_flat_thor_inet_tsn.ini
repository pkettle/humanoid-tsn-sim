[General]
network = omnet.FlatThorInetTsn
sim-time-limit = 0.5s
result-dir = "results/tsn"

# =============================================================================
# 1. IPv4 CONFIGURATOR (ROUTING)
# =============================================================================
*.configurator.addStaticRoutes               = true
*.configurator.addDefaultRoutes              = true
*.configurator.optimizeRoutes                = true
*.configurator.assignDisjunctSubnetAddresses = true

# =============================================================================
# 2. LINK BITRATES (1 Gbps EVERYWHERE)
# =============================================================================
*.thor.eth[*].bitrate         = 1Gbps
*.zone[*].eth[*].bitrate      = 1Gbps
*.coreSwitch.eth[*].bitrate   = 1Gbps
*.accessSwitch.eth[*].bitrate = 1Gbps

# =============================================================================
# 3. APPLICATIONS: CONTROL (Qbv) + SENSOR (Qav) + TELEMETRY (BE)
# =============================================================================

# Thor: 3 apps = CONTROL (Qbv), SENSOR (Qav), TELEMETRY (BE)
*.thor.numApps = 3

# Zones:
#   zone[0]: CONTROL sink only
#   zone[1]: SENSOR + TELEMETRY sinks
*.zone[0].numApps = 1
*.zone[1].numApps = 3

*.thor.app[*].recordStatistics    = true
*.zone[*].app[*].recordStatistics = true

# ------------------------------------------------------------------------
# 3.1 CONTROL: Qbv-class stream (high-priority, deterministic)
#     thor.app[0] -> zone[0].app[0], UDP port 5000
# ------------------------------------------------------------------------
*.thor.app[0].typename      = "UdpBasicApp"
*.thor.app[0].destAddresses = "zone[0]"
*.thor.app[0].destPort      = 5000
*.thor.app[0].messageLength = 512B
*.thor.app[0].sendInterval  = 1ms
*.thor.app[0].startTime     = 0.001s
*.thor.app[0].stopTime      = 0.4s
*.thor.app[0].packetName    = "ctrl_qbv"

*.zone[0].app[0].typename                 = "UdpSink"
*.zone[0].app[0].localPort                = 5000
*.zone[0].app[0].joinLocalMulticastGroups = false
*.zone[0].app[0].receiveBroadcast         = true

# -----------------------------------------------------------------------------
# Zone[1] app[0]: dummy sink (unused slot to satisfy numApps = 3)
# -----------------------------------------------------------------------------
*.zone[1].app[0].typename                 = "UdpSink"
*.zone[1].app[0].localPort                = 0      # no matching sender uses this
*.zone[1].app[0].joinLocalMulticastGroups = false
*.zone[1].app[0].receiveBroadcast         = false
*.zone[1].app[0].recordStatistics         = false

# ------------------------------------------------------------------------
# 3.2 SENSOR: Qav-class stream (medium-priority, higher bandwidth)
#     thor.app[1] -> zone[1].app[1], UDP port 5100
# ------------------------------------------------------------------------
*.thor.app[1].typename      = "UdpBasicApp"
*.thor.app[1].destAddresses = "zone[1]"
*.thor.app[1].destPort      = 5100
*.thor.app[1].messageLength = 1024B
*.thor.app[1].sendInterval  = 2ms
*.thor.app[1].startTime     = 0.001s
*.thor.app[1].stopTime      = 0.4s
*.thor.app[1].packetName    = "sensor_qav"

*.zone[1].app[1].typename                 = "UdpSink"
*.zone[1].app[1].localPort                = 5100
*.zone[1].app[1].joinLocalMulticastGroups = false
*.zone[1].app[1].receiveBroadcast         = true

# ------------------------------------------------------------------------
# 3.3 TELEMETRY: Best-effort stream
#     thor.app[2] -> zone[1].app[2], UDP port 5200
# ------------------------------------------------------------------------
*.thor.app[2].typename      = "UdpBasicApp"
*.thor.app[2].destAddresses = "zone[1]"
*.thor.app[2].destPort      = 5200
*.thor.app[2].messageLength = 1024B
*.thor.app[2].sendInterval  = 5ms
*.thor.app[2].startTime     = 0.001s
*.thor.app[2].stopTime      = 0.4s
*.thor.app[2].packetName    = "telemetry_be"

*.zone[1].app[2].typename                 = "UdpSink"
*.zone[1].app[2].localPort                = 5200
*.zone[1].app[2].joinLocalMulticastGroups = false
*.zone[1].app[2].receiveBroadcast         = true
*.zone[1].app[2].recordStatistics         = true

# ------------------------------------------------------------------------
# 3.4 STREAM IDENTIFICATION + PCP TAGGING (CONTROL / SENSOR / TELEMETRY)
#     IEEE-aligned PCP usage:
#       CONTROL   → stream "control"   → PCP 7 (highest, network/control)
#       SENSOR    → stream "sensor"    → PCP 4 (AVB/Qav class)
#       TELEMETRY → stream "telemetry" → PCP 1 (background / BE)
#
#     NOTE: Only Thor sends traffic in this baseline, so only Thor needs
#           hasOutgoingStreams + encoder mapping.
# ------------------------------------------------------------------------

*.thor.hasOutgoingStreams = true

*.thor.bridging.streamIdentifier.identifier.mapping = [ \
    { stream: "control",   packetFilter: expr(has(udp) && udp.destPort == 5000) }, \
    { stream: "sensor",    packetFilter: expr(has(udp) && udp.destPort == 5100) }, \
    { stream: "telemetry", packetFilter: expr(has(udp) && udp.destPort == 5200) } \
]

# CONTROL   → PCP 7 (highest)
# SENSOR    → PCP 4 (Qav)
# TELEMETRY → PCP 1 (background / BE)
*.thor.bridging.streamCoder.encoder.mapping = [ \
    { stream: "control",   pcp: 7 }, \
    { stream: "sensor",    pcp: 4 }, \
    { stream: "telemetry", pcp: 1 } \
]

# Optional: decode PCP back into streams at the switches for clarity
*.coreSwitch.bridging.streamCoder.decoder.mapping = [ \
    { pcp: 7, stream: "control"   }, \
    { pcp: 4, stream: "sensor"    }, \
    { pcp: 1, stream: "telemetry" } \
]

*.accessSwitch.bridging.streamCoder.decoder.mapping = [ \
    { pcp: 7, stream: "control"   }, \
    { pcp: 4, stream: "sensor"    }, \
    { pcp: 1, stream: "telemetry" } \
]

# =============================================================================
# 4. TSN: THREE TRAFFIC CLASSES WITH Qbv (CONTROL) + Qav (SENSOR) + BE (TELEM)
#
#   traffic class 0: CONTROL (Qbv-gated, highest priority)
#   traffic class 1: SENSOR  (Qav / Credit-Based Shaper)
#   traffic class 2: TELEMETRY (Best Effort)
#
#   Qbv schedule: 2 ms cycle
#     - Class 0 (CONTROL):   [1 ms open, 1 ms closed]
#     - Class 1 (SENSOR):    [2 ms open, tiny closed]  → effectively always open
#     - Class 2 (TELEMETRY): [2 ms open, tiny closed]  → effectively always open
# =============================================================================

*.coreSwitch.hasEgressTrafficShaping   = true
*.accessSwitch.hasEgressTrafficShaping = true

*.coreSwitch.eth[*].macLayer.queue.numTrafficClasses   = 3
*.accessSwitch.eth[*].macLayer.queue.numTrafficClasses = 3

# Optional cosmetics for inspection
*.coreSwitch.eth[*].macLayer.queue.*[0].display-name   = "CONTROL-Qbv"
*.coreSwitch.eth[*].macLayer.queue.*[1].display-name   = "SENSOR-Qav"
*.coreSwitch.eth[*].macLayer.queue.*[2].display-name   = "TELEM-BE"

*.accessSwitch.eth[*].macLayer.queue.*[0].display-name = "CONTROL-Qbv"
*.accessSwitch.eth[*].macLayer.queue.*[1].display-name = "SENSOR-Qav"
*.accessSwitch.eth[*].macLayer.queue.*[2].display-name = "TELEM-BE"

# ------------------------------------------------------------------------
# 4.1 Qav / Credit-Based Shaper (SENSOR traffic, traffic class 1)
# ------------------------------------------------------------------------

*.coreSwitch.eth[*].macLayer.queue.transmissionSelectionAlgorithm[1].typename   = "Ieee8021qCreditBasedShaper"
*.accessSwitch.eth[*].macLayer.queue.transmissionSelectionAlgorithm[1].typename = "Ieee8021qCreditBasedShaper"

# Reserve part of the link capacity for SENSOR streams.
*.coreSwitch.eth[*].macLayer.queue.transmissionSelectionAlgorithm[1].idleSlope   = 60Mbps
*.accessSwitch.eth[*].macLayer.queue.transmissionSelectionAlgorithm[1].idleSlope = 60Mbps

# ------------------------------------------------------------------------
# 4.2 Qbv GATE SCHEDULE (2 ms CYCLE) PER TRAFFIC CLASS
# ------------------------------------------------------------------------

# --- Class 0 (CONTROL / Qbv) ---
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[0].offset        = 0ms
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[0].durations     = [1ms, 1ms]
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[0].initiallyOpen = true

*.accessSwitch.eth[*].macLayer.queue.transmissionGate[0].offset        = 0ms
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[0].durations     = [1ms, 1ms]
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[0].initiallyOpen = true

# --- Class 1 (SENSOR / Qav): effectively always open (2 ms open, 1 ns closed) ---
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[1].offset        = 0ms
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[1].durations     = [2ms, 1ns]
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[1].initiallyOpen = true

*.accessSwitch.eth[*].macLayer.queue.transmissionGate[1].offset        = 0ms
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[1].durations     = [2ms, 1ns]
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[1].initiallyOpen = true

# --- Class 2 (TELEMETRY / Best Effort): effectively always open (2 ms open, 1 ns closed) ---
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[2].offset        = 0ms
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[2].durations     = [2ms, 1ns]
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[2].initiallyOpen = true

*.accessSwitch.eth[*].macLayer.queue.transmissionGate[2].offset        = 0ms
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[2].durations     = [2ms, 1ns]
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[2].initiallyOpen = true

# =============================================================================
# 5. STATISTICS (GLOBAL + APP-LEVEL)
# =============================================================================
**.result-recording-modes = all
**.scalar-recording       = true
**.vector-recording       = true

*.thor.app[*].recordStatistics    = true
*.zone[*].app[*].recordStatistics = true

**.endToEndDelay.statistic-recording = true
**.oneWayDelay.statistic-recording   = true
**.delay.statistic-recording         = true

*.zone[*].app[0].endToEndDelay.result-recording-modes = "vector,histogram"
*.zone[*].app[1].endToEndDelay.result-recording-modes = "vector,histogram"
*.zone[*].app[2].endToEndDelay.result-recording-modes = "vector,histogram"
