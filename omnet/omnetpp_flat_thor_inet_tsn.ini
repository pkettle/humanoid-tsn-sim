[General]
network = omnet.FlatThorInetTsn
sim-time-limit = 0.5s
result-dir = "results/tsn"

# =============================================================================
# 1. IPv4 CONFIGURATOR (ROUTING)
# =============================================================================
*.configurator.addStaticRoutes               = true
*.configurator.addDefaultRoutes              = true
*.configurator.optimizeRoutes                = true
*.configurator.assignDisjunctSubnetAddresses = true

# =============================================================================
# 2. LINK BITRATES (1 Gbps EVERYWHERE)
# =============================================================================
*.thor.eth[*].bitrate         = 1Gbps
*.zone[*].eth[*].bitrate      = 1Gbps
*.coreSwitch.eth[*].bitrate   = 1Gbps
*.accessSwitch.eth[*].bitrate = 1Gbps

# =============================================================================
# 3. APPLICATIONS: CONTROL (Qbv) + SENSOR (Qav) + TELEMETRY (BE)
# =============================================================================

# Thor: 3 apps = CONTROL (Qbv), SENSOR (Qav), TELEMETRY (BE)
*.thor.numApps = 3

# Zones:
#   zone[0]: CONTROL sink only
#   zone[1]: SENSOR + TELEMETRY sinks
*.zone[0].numApps = 1
*.zone[1].numApps = 3

*.thor.app[*].recordStatistics    = true
*.zone[*].app[*].recordStatistics = true

# ------------------------------------------------------------------------
# 3.1 CONTROL: Qbv-class stream (high-priority, deterministic)
#     thor.app[0] -> zone[0].app[0], UDP port 5000
# ------------------------------------------------------------------------
*.thor.app[0].typename      = "UdpBasicApp"
*.thor.app[0].destAddresses = "zone[0]"
*.thor.app[0].destPort      = 5000
*.thor.app[0].messageLength = 512B
*.thor.app[0].sendInterval  = 1ms
*.thor.app[0].startTime     = 0.001s
*.thor.app[0].stopTime      = 0.4s
*.thor.app[0].packetName    = "ctrl_qbv"

*.zone[0].app[0].typename                 = "UdpSink"
*.zone[0].app[0].localPort                = 5000
*.zone[0].app[0].joinLocalMulticastGroups = false
*.zone[0].app[0].receiveBroadcast         = true

# -----------------------------------------------------------------------------
# Zone[1] app[0]: dummy sink (unused slot to satisfy numApps = 3)
# -----------------------------------------------------------------------------
*.zone[1].app[0].typename                 = "UdpSink"
*.zone[1].app[0].localPort                = 0      # no matching sender uses this
*.zone[1].app[0].joinLocalMulticastGroups = false
*.zone[1].app[0].receiveBroadcast         = false
*.zone[1].app[0].recordStatistics         = false

# ------------------------------------------------------------------------
# 3.2 SENSOR: Qav-class stream (medium-priority, higher bandwidth)
#     thor.app[1] -> zone[1].app[1], UDP port 5100
# ------------------------------------------------------------------------
*.thor.app[1].typename      = "UdpBasicApp"
*.thor.app[1].destAddresses = "zone[1]"
*.thor.app[1].destPort      = 5100
*.thor.app[1].messageLength = 1024B
*.thor.app[1].sendInterval  = 2ms
*.thor.app[1].startTime     = 0.001s
*.thor.app[1].stopTime      = 0.4s
*.thor.app[1].packetName    = "sensor_qav"

*.zone[1].app[1].typename                 = "UdpSink"
*.zone[1].app[1].localPort                = 5100
*.zone[1].app[1].joinLocalMulticastGroups = false
*.zone[1].app[1].receiveBroadcast         = true

# ------------------------------------------------------------------------
# 3.3 TELEMETRY: Best-effort stream
#     thor.app[2] -> zone[1].app[2], UDP port 5200
# ------------------------------------------------------------------------
*.thor.app[2].typename      = "UdpBasicApp"
*.thor.app[2].destAddresses = "zone[1]"
*.thor.app[2].destPort      = 5200
*.thor.app[2].messageLength = 1024B
*.thor.app[2].sendInterval  = 5ms
*.thor.app[2].startTime     = 0.001s
*.thor.app[2].stopTime      = 0.4s
*.thor.app[2].packetName    = "telemetry_be"

*.zone[1].app[2].typename                 = "UdpSink"
*.zone[1].app[2].localPort                = 5200
*.zone[1].app[2].joinLocalMulticastGroups = false
*.zone[1].app[2].receiveBroadcast         = true
*.zone[1].app[2].recordStatistics         = true

# =============================================================================
# 4. TSN: TWO TRAFFIC CLASSES WITH Qbv SCHEDULE
#    class 0 = TSN (gated)
#    class 1 = best-effort (Qav + BE share this class for now)
# =============================================================================
*.coreSwitch.hasEgressTrafficShaping   = true
*.accessSwitch.hasEgressTrafficShaping = true

*.coreSwitch.eth[*].macLayer.queue.numTrafficClasses   = 2
*.accessSwitch.eth[*].macLayer.queue.numTrafficClasses = 2

# --- Class 0 (TSN / CONTROL): 2 ms cycle, 1 ms OPEN, 1 ms CLOSED ---
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[0].offset        = 0ms
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[0].durations     = [1ms, 1ms]
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[0].initiallyOpen = true

*.accessSwitch.eth[*].macLayer.queue.transmissionGate[0].offset        = 0ms
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[0].durations     = [1ms, 1ms]
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[0].initiallyOpen = true

# --- Class 1 (BEST-EFFORT / SENSOR + TELEMETRY):
#     effectively always open (2 ms OPEN, 1 ns CLOSED)
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[1].offset        = 0ms
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[1].durations     = [2ms, 1ns]
*.coreSwitch.eth[*].macLayer.queue.transmissionGate[1].initiallyOpen = true

*.accessSwitch.eth[*].macLayer.queue.transmissionGate[1].offset        = 0ms
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[1].durations     = [2ms, 1ns]
*.accessSwitch.eth[*].macLayer.queue.transmissionGate[1].initiallyOpen = true

# =============================================================================
# 5. STATISTICS (GLOBAL + APP-LEVEL)
# =============================================================================
**.result-recording-modes = all
**.scalar-recording       = true
**.vector-recording       = true

*.thor.app[*].recordStatistics    = true
*.zone[*].app[*].recordStatistics = true

**.endToEndDelay.statistic-recording = true
**.oneWayDelay.statistic-recording   = true
**.delay.statistic-recording         = true

*.zone[*].app[0].endToEndDelay.result-recording-modes = "vector,histogram"
*.zone[*].app[1].endToEndDelay.result-recording-modes = "vector,histogram"
*.zone[*].app[2].endToEndDelay.result-recording-modes = "vector,histogram"
